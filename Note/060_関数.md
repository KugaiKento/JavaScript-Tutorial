# 関数

関数は実行可能なオブジェクトである。

プリミティブ型の 7 つの型以外のすべての変数がオブジェクトということになる。

## arguments

関数コンテキストによって自動的に生成されるもの。オブジェクトであり、呼び出し時に渡された実引数が渡ってくることになる。arguments というオブジェクトは渡される引数の数が決まっていない場合に使われることがあるが、基本的には Rest Parameters を使う方が良い。

```JavaScript

//デフォルト値undefinedの場合はデフォルト値が優先される。
function fn1(a, b = 1) {
  console.log(arguments);
  console.log(a, b);
}

//引数が一致している必要はない。
fn1(1);

```

## コールバック関数

他の関数の引数として渡される関数

```JavaScript
function hello(name) {
  console.log("hello" + name);
}

function bye() {
  console.log("bye");
}

function fn(cb) {
  cb("Tom");
}

fn(hello);
fn(bye);

//無名関数でも設定可能
fn(function (name) {
  console.log("hello" + name);
});

```

コールバック関数が有効な理由は汎用的に使える部品を作成できる点でがある。例えば、`setTimeout(hello,2000)`のように何ミリ秒待った後に実行するという処理をコールバック関数に切り分けることでこの部品が使いまわし可能な状態になる。

コードの再利用性が高まるため、JavaScript でよく使われる記述方法になる。

## this

- 呼び出し元のオブジェクトへの参照を保持するキーワード。
- 実行コンテキストによって参照先が変わる。

```JavaScript
const person = {
  name: "Tom",
  hello: function () {
    console.log("hello" + this.name);
  },
};

person.hello();
```

### メソッドを他の変数にコピーしたときの挙動

この場合、`ref`は`Hello john`を出力する。

```JavaScript
window.name = "john";

const person = {
  name: "Tom",
  hello: function () {
    console.log("Hello " + this.name);
  },
};
const ref = person.hello;
ref();
```

これは`person`の`hello`を`ref`にコピーすると`hello`というプロパティの参照している先の関数がまずメモリにコピーされる。こちらの関数に対して`ref`から参照されるということになる。

このため呼び出し元のオブジェクトが`person`ではなくなるため、`name`で`Tom`という文字列が取れてこないことになる。

なぜ window オブジェクトに格納された name プロパティが取れてくるかというと、オブジェクトのメソッドとして実行される場合は this は呼び出し元のオブジェクトを参照することになるが、関数として単に実行された場合は this はグローバルオブジェクトを参照することになる。

オブジェクトのメソッド：<br>
`this => 呼び出し元のオブジェクト`<br>

関数として実行される場合：<br>
`this => グローバルオブジェクト`

## bind

```js
function a(name) {
  console.log("Hello", name);
}

const b = a.bind(null, "Tim");
b();
```

bind メソッドでは this や引数を固定した新たな関数が作成される。

```js
window.name = "John";

const person = {
  name: "Tom",
  hello: function () {
    console.log("Hello " + this.name);
  },
};

const helloTom = person.hello.bind(person);
function fn(ref) {
  ref();
}

//hello john
fn(helloTom);
```

まず、オブジェクトの person の hello プロパティから関数への参照が貼られている。この状態から person の hello に対して bind メソッドを呼ぶと bind メソッドによって function`の中身の this は固定され、hello の参照先の関数ではなく他の関数として新たにメモリ空間に追加される。

ポイントは hello の参照している関数とは別の関数がメモリ空間に this の値が固定され生成されることになる。

このため`helloTom`をどのような状況で呼び出したとしても、新たに生成された function`は this が固定されているの状態なので HelloTom が出力されることになる。

このようなことを`bindによるthisの束縛`と表現したりする。

## call と apply

call,apply は bind と似ているが、違いは bind は this や引数の参照先を変更するが、使用時点では実行しないのに対し、call,apply は this や引数の参照先を変更と同時に関数を実行するという性質がある。

### apply と call の違い

配列を扱う場合は apply がよく使われる。<br>
bind と call の使い方はほぼ同じだが、call は関数の実行まで行われることが異なってくる点になる。

```js
function a(name, name1) {
  console.log("hello " + name + " " + name1);
}

const tim = { name: "Tim" };

a.apply(tim, ["Tim", "Bob"]);
a.call(tim, "Tim");
```

## アロー関数

ES6 で導入された無名関数を記述しやすくした省略記法`() => {}`のように書き矢印部分がアローに似ているためアロー関数と呼ばれている。

無名関数をアロー関数に書き換えることによって記述量を少なくできるが一部のケースでは、無名関数とアロー関数は異なる挙動をとる。

|           | 無名関数 | アロー関数 |
| --------- | -------- | ---------- |
| this      | 〇       | ×          |
| arguments | 〇       | ×          |
| new       | 〇       | ×          |
| prototype | 〇　     | ×          |

アロー関数では this や arguments という値は保持せず、new 演算子を使った初期化も行うことができない。<br>

```js
window.name = "John";

const person = {
  name: "Tom",
  hello: () => {
    console.log("Hello " + this.name);
  },
};
//Hello Johnが出力される
person.hello();
```

アロー関数ではレキシカルスコープの this が参照されることになる。
