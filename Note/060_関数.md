# 関数

関数は実行可能なオブジェクトである。

プリミティブ型の 7 つの型以外のすべての変数がオブジェクトということになる。

## arguments

関数コンテキストによって自動的に生成されるもの。オブジェクトであり、呼び出し時に渡された実引数が渡ってくることになる。arguments というオブジェクトは渡される引数の数が決まっていない場合に使われることがあるが、基本的には Rest Parameters を使う方が良い。

```JavaScript

//デフォルト値undefinedの場合はデフォルト値が優先される。
function fn1(a, b = 1) {
  console.log(arguments);
  console.log(a, b);
}

//引数が一致している必要はない。
fn1(1);

```

## コールバック関数

他の関数の引数として渡される関数

```JavaScript
function hello(name) {
  console.log("hello" + name);
}

function bye() {
  console.log("bye");
}

function fn(cb) {
  cb("Tom");
}

fn(hello);
fn(bye);

//無名関数でも設定可能
fn(function (name) {
  console.log("hello" + name);
});

```

コールバック関数が有効な理由は汎用的に使える部品を作成できる点でがある。例えば、`setTimeout(hello,2000)`のように何ミリ秒待った後に実行するという処理をコールバック関数に切り分けることでこの部品が使いまわし可能な状態になる。

コードの再利用性が高まるため、JavaScript でよく使われる記述方法になる。

## this

- 呼び出し元のオブジェクトへの参照を保持するキーワード。
- 実行コンテキストによって参照先が変わる。

```JavaScript
const person = {
  name: "Tom",
  hello: function () {
    console.log("hello" + this.name);
  },
};

person.hello();
```

### メソッドを他の変数にコピーしたときの挙動

この場合、`ref`は`Hello john`を出力する。

```JavaScript
window.name = "john";

const person = {
  name: "Tom",
  hello: function () {
    console.log("Hello " + this.name);
  },
};
const ref = person.hello;
ref();
```

これは`person`の`hello`を`ref`にコピーすると`hello`というプロパティの参照している先の関数がまずメモリにコピーされる。こちらの関数に対して`ref`から参照されるということになる。

このため呼び出し元のオブジェクトが`person`ではなくなるため、`name`で`Tom`という文字列が取れてこないことになる。

なぜ window オブジェクトに格納された name プロパティが取れてくるかというと、オブジェクトのメソッドとして実行される場合は this は呼び出し元のオブジェクトを参照することになるが、関数として単に実行された場合は this はグローバルオブジェクトを参照することになる。

オブジェクトのメソッド：<br>
`this => 呼び出し元のオブジェクト`<br>

関数として実行される場合：<br>
`this => グローバルオブジェクト`
